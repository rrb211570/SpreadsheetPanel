{"ast":null,"code":"import { getInLine, nextTurn } from '../../../../tests/sequenceHelpers.js';\nimport { getResizableColData, getResizableRowData } from './resizingHandler.js';\nimport { store } from './../../../../store/store.js';\nimport { logError, logSuccess } from '../../../../tests/helper.js';\nfunction resizersTests(turn) {\n  let axisCellsX = document.querySelectorAll('.AxisX');\n  let axisCellsY = document.querySelectorAll('.AxisY');\n  let resizeSelections = [[axisCellsX, -5], [axisCellsY, -1], [[axisCellsX[0]], 15], [axisCellsY, 12], [[axisCellsX[0]], 20], [[axisCellsY[0]], 12]];\n  try {\n    if (resizeSelections.length > 0) checkReactionOfResizing(1, resizeSelections[0], turn, true, resizeSelections.length);\n    for (let i = 1; i < resizeSelections.length; ++i) checkReactionOfResizing(i + 1, resizeSelections[i], turn, false, resizeSelections.length);\n  } catch (e) {\n    console.log('resizingErr: checkReactionOfResizing param error: ' + e);\n    logError(null, e);\n  }\n}\nfunction checkHorizontalResizersInitialization() {\n  try {\n    let elems = document.querySelectorAll('.AxisX');\n    let logMsg = '';\n    elems.forEach((elem, idx) => {\n      let resizer = elem.querySelector('.resizer-horizontal');\n      if (resizer == null) {\n        logMsg = logMsg + 'col' + (idx + 1) + ': horizontal resizer not found\\n';\n      } else if (22 != parseInt(resizer.style.height, 10)) {\n        logMsg = logMsg + 'col' + (idx + 1) + ': horizontal resizer does not match height of Y-axis cell \\'' + resizer.style.height + '\\' : should be \\'22px\\' \\n';\n      }\n    });\n    if (logMsg.length != 0) console.log(logMsg);else console.log('horizontalResizers appended correctly');\n  } catch (error) {\n    console.log('checkHorizontalResizersInitialization(): ' + error);\n  }\n}\nfunction checkVerticalResizersInitialization() {\n  try {\n    let elems = document.querySelectorAll('.AxisY');\n    let logMsg = '';\n    elems.forEach((elem, idx) => {\n      let resizer = elem.querySelector('.resizer-vertical');\n      if (resizer == null) {\n        logMsg = logMsg + 'row' + idx + ': vertical resizer not found\\n';\n      } else if (50 != parseInt(resizer.style.width, 10)) {\n        logMsg = logMsg + 'row' + idx + ': vertical resizer does not match width of X-axis cell \\'' + resizer.style.width + '\\' : should be \\'50px\\'\\n';\n      }\n    });\n    if (logMsg.length != 0) console.log(logMsg);else console.log('verticalResizers appended correctly');\n  } catch (error) {\n    console.log('checkVerticalResizersInitialization(): ' + error);\n  }\n}\nfunction checkReactionOfResizing(testCaseIndex, resizeDetails, turn, isFirstCall, totalTestCases) {\n  let timer;\n  let [axisCells, deltaIncrement] = resizeDetails;\n  try {\n    let axisClass = getAxisClass(axisCells);\n    let resizer;\n    let delta = 0;\n    let index = -1;\n    let myTurnNumber = getInLine(turn);\n    let mouseState = -1;\n    let dimensionsBeforeMove;\n    let dimensionsAfterMove;\n    let changeHistoryBeforeMove;\n    let changeHistoryIndexBeforeMove;\n    let changeHistoryAfterMove;\n    let changeHistoryIndexAfterMove;\n    timer = setInterval(() => {\n      switch (mouseState) {\n        case -1:\n          // FIFO waiting queue\n          if (turn.current == myTurnNumber) {\n            if (isFirstCall) {\n              console.log('\\n--------RESIZING TEST-----------------------');\n              checkHorizontalResizersInitialization();\n              checkVerticalResizersInitialization();\n            }\n            mouseState = 0;\n          }\n          break;\n        case 0:\n          if (++index < axisCells.length) {\n            resizer = getResizer(axisCells[index], axisClass);\n            mouseState++;\n          } else {\n            console.log('resizing affects store and DOM correctly');\n            if (testCaseIndex == totalTestCases) logSuccess('resizingTest()', totalTestCases);\n            nextTurn(turn); // increment turn.current\n            clearInterval(timer);\n          }\n          break;\n        case 1:\n          resizer.dispatchEvent(new MouseEvent('mousedown', {\n            bubbles: true,\n            cancelable: true,\n            clientX: 0\n          }));\n          try {\n            dimensionsBeforeMove = captureResizerData(axisClass, axisCells[index]);\n            let historyState = store.getState().history;\n            [changeHistoryBeforeMove, changeHistoryIndexBeforeMove] = [historyState.changeHistory, historyState.changeHistoryIndex];\n          } catch (error) {\n            console.log('resizingErr: ' + error);\n            clearInterval(timer);\n          }\n          mouseState++;\n          break;\n        case 2:\n        case 3:\n        case 4:\n          let params = {\n            bubbles: true,\n            cancelable: true\n          };\n          params[axisClass == 'AxisX' ? 'clientX' : 'clientY'] = delta += deltaIncrement;\n          resizer.dispatchEvent(new MouseEvent('mousemove', params));\n          mouseState++;\n          break;\n        case 5:\n          resizer.dispatchEvent(new MouseEvent('mouseup', {\n            bubbles: true,\n            cancelable: true\n          }));\n          try {\n            dimensionsAfterMove = captureResizerData(axisClass, axisCells[index]);\n            let historyState = store.getState().history;\n            [changeHistoryAfterMove, changeHistoryIndexAfterMove] = [historyState.changeHistory, historyState.changeHistoryIndex];\n            if (!expectedTableChanges(axisClass, dimensionsBeforeMove, dimensionsAfterMove, delta)) throw 'mousemove: resizer not affecting table correctly';\n            if (!expectedChangeHistoryChanges(axisClass, delta, changeHistoryBeforeMove, changeHistoryIndexBeforeMove, changeHistoryAfterMove, changeHistoryIndexAfterMove)) throw 'mousemove: resizer not affecting changeHistory properly';\n          } catch (error) {\n            console.log('resizingErr: ' + error);\n            clearInterval(timer);\n          }\n          delta = 0;\n          mouseState = 0;\n          break;\n        default:\n          break;\n      }\n    }, 5);\n  } catch (e) {\n    let errMsg = 'Err: checkReactionOfResizing(): { testCaseIndex: ' + testCaseIndex + ' } : ' + e;\n    console.log(errMsg);\n    logError(errMsg);\n    clearInterval(timer);\n  }\n}\nfunction getAxisClass(axisCells) {\n  let arr = [];\n  if (typeof axisCells !== typeof arr) throw 'getAxisClass(): axisCells is not an array';\n  if (axisCells.length == 0) throw 'getAxisClass(): axisCells is empty';\n  if (axisCells instanceof Element) throw 'getAxisClass(): axisCells should be an array of DOM elements';\n  if (!(axisCells[0] instanceof Element)) throw 'getAxisClass(): axisCells should be an array of DOM elements';\n  let axisName = [...axisCells[0].classList].filter(name => /^Axis.$/.test(name));\n  if (axisName.length == 0) throw 'getAxisClass(): axisClass not found in axisCells[0]';\n  if (axisName[0] != 'AxisX' && axisName[0] != 'AxisY') throw 'getAxisClass(): found axis class not equal to \"AxisX\" or \"AxisY\"';\n  return axisName[0];\n}\nfunction getResizer(axisCell, axisClass) {\n  if (!(axisCell instanceof Element)) throw 'getResizer(): axisCell should be a valid DOM element';\n  let reg = new RegExp(axisClass);\n  let possibleAxisClass = [...axisCell.classList].filter(name => reg.test(name));\n  if (possibleAxisClass.length == 0) throw 'getResizer(): axisCell\\'s axis class must match axis parameter';\n  let resizer = axisCell.querySelector(axisClass == 'AxisX' ? '.resizer-horizontal' : '.resizer-vertical');\n  if (!resizer instanceof Element) throw 'getResizer(): resizer not found in axisCell';\n  return resizer;\n}\nfunction captureResizerData(axisClass, axisCell) {\n  let tableDimensions = store.getState().tableDimensions;\n  if (axisClass == 'AxisX') {\n    let colNum = getResizerIndex(axisClass, axisCell);\n    let cellWidth = parseInt(axisCell.style.width, 10);\n    return getResizableColData(colNum, cellWidth, tableDimensions.width);\n  } else {\n    let rowNum = getResizerIndex(axisClass, axisCell);\n    let cellHeight = parseInt(axisCell.style.height, 10);\n    return getResizableRowData(rowNum, cellHeight, tableDimensions.height);\n  }\n}\nfunction getResizerIndex(axisClass, axisCell) {\n  if (axisClass == 'AxisX') return parseInt([...axisCell.classList].filter(name => /^col\\d+$/.test(name))[0].slice(-1), 10);else return parseInt([...axisCell.classList].filter(name => /^row\\d+$/.test(name))[0].slice(-1), 10);\n}\n\n// check that when delta is applied to all width/marginLeft values in dimensionsBeforeMove,\n// that it is reflected in dimensionsAfterMove\nfunction expectedTableChanges(axisClass, dimensionsBeforeMove, dimensionsAfterMove, delta) {\n  try {\n    if (axisClass == 'AxisX') {\n      for (const [entryKey, data] of dimensionsBeforeMove.getIndividualEntries()) {\n        if (!dimensionsAfterMove.hasIndividualEntry(entryKey)) throw entryKey + ' in dimensionsBeforeMove, but not found in dimensionsAfterMove';\n        let dataAfter = dimensionsAfterMove.getIndividualEntry(entryKey);\n        let beforeStyleMap = data.getStyleMap();\n        let afterStyleMap = dataAfter.getStyleMap();\n        if (beforeStyleMap.size != 1 || afterStyleMap.size != 1) throw entryKey + ' should not have multiple styleMap entries';\n        if (entryKey == 'table') {\n          if (beforeStyleMap.get('width') == null || afterStyleMap.get('width') == null) throw entryKey + ' is missing property \"width\"';\n          if (beforeStyleMap.get('width') + delta != afterStyleMap.get('width')) throw entryKey + ' width not updated properly';\n        } else if (!/.col\\d+/.test(entryKey)) {\n          if (beforeStyleMap.get('width') == null || afterStyleMap.get('width') == null) throw entryKey + ' is missing property \"width\"';\n          if (beforeStyleMap.get('width') + delta != afterStyleMap.get('width')) throw entryKey + ' width not updated properly';\n          if (data.row != dataAfter.row) throw entryKey + ' row does not match';\n        } else {\n          if (data.cellRow != dataAfter.cellRow) throw entryKey + ' row does not match';\n          if (data.cellCol != dataAfter.cellCol) throw entryKey + ' col does not match';\n          if (data.val != dataAfter.val) throw entryKey + ' val does not match';\n          if (beforeStyleMap.get('width') == null) {\n            if (beforeStyleMap.get('marginLeft') == null || afterStyleMap.get('marginLeft') == null) throw entryKey + ' is missing property \"marginLeft\"';\n            if (beforeStyleMap.get('marginLeft') + delta != afterStyleMap.get('marginLeft')) throw entryKey + ' marginLeft not updated properly';\n          } else {\n            if (afterStyleMap.get('width') == null) throw entryKey + ' is missing property \"width\"';\n            if (beforeStyleMap.get('width') + delta != afterStyleMap.get('width')) throw entryKey + ' width not updated properly';\n          }\n        }\n      }\n    } else {\n      for (const [entryKey, data] of dimensionsBeforeMove.getIndividualEntries()) {\n        if (!dimensionsAfterMove.hasIndividualEntry(entryKey)) throw entryKey + ' in dimensionsBeforeMove, but not found in dimensionsAfterMove';\n        let dataAfter = dimensionsAfterMove.getIndividualEntry(entryKey);\n        let beforeStyleMap = data.getStyleMap();\n        let afterStyleMap = dataAfter.getStyleMap();\n        if (beforeStyleMap.size != 1 || afterStyleMap.size != 1) throw entryKey + ' should not have multiple styleMap entries';\n        if (beforeStyleMap.get('height') == null || afterStyleMap.get('height') == null) throw entryKey + ' is missing property \"height\"';\n        if (beforeStyleMap.get('height') + delta != afterStyleMap.get('height')) throw entryKey + ' height not updated properly';\n        if (!/.col\\d+/.test(entryKey)) {\n          if (data.row != dataAfter.row) throw entryKey + ' row does not match';\n        } else {\n          if (data.cellRow != dataAfter.cellRow) throw entryKey + ' row does not match';\n          if (data.cellCol != dataAfter.cellCol) throw entryKey + ' col does not match';\n          if (data.val != dataAfter.val) throw entryKey + ' val does not match';\n        }\n      }\n    }\n    return true;\n  } catch (error) {\n    throw 'expectedTableChanges(): ' + error;\n  }\n}\nfunction expectedChangeHistoryChanges(axisClass, delta, changeHistoryBeforeMove, changeHistoryIndexBeforeMove, changeHistoryAfterMove, changeHistoryIndexAfterMove) {\n  try {\n    if (changeHistoryIndexBeforeMove != changeHistoryIndexAfterMove - 1) throw 'changeHistoryIndex not updated properly';\n    // preservation\n    for (const [entryKey, value] of changeHistoryBeforeMove[changeHistoryIndexBeforeMove].getIndividualEntries()) {\n      if (!changeHistoryAfterMove[changeHistoryIndexBeforeMove].hasIndividualEntry(entryKey)) throw 'entry not preserved';\n      let valueAfterMove = changeHistoryAfterMove[changeHistoryIndexBeforeMove].getIndividualEntry(entryKey);\n      if (value.getStyleMap().size != valueAfterMove.getStyleMap().size) throw \"valueAfterMove does not preserve  styleMap pairs of value\";\n      let valueAfterMoveStyleMap = valueAfterMove.getStyleMap();\n      for (const [property, val] of value.getStyleMap().entries()) {\n        if (valueAfterMoveStyleMap.get(property) !== val) throw 'valueAfterMove does not preserve styleMap pairs of value';\n      }\n      if (!/.col\\d+/.test(entryKey) && entryKey !== 'table' && value.getRow() != valueAfterMove.getRow()) throw 'valueAfterMove does not preserve row of value';else if (/.col\\d+/.test(entryKey) && (value.getCellRow() != valueAfterMove.getCellRow() || value.getCellCol() != valueAfterMove.getCellCol() || value.getVal() != valueAfterMove.getVal())) throw 'valueAfterMove does not preserve cellRow/cellCol/val of value';\n    }\n    // check resizing is reflected in changeHistoryAfterMove\n    for (const [entryKey, valueAfterMove] of changeHistoryAfterMove[changeHistoryIndexAfterMove].getIndividualEntries()) {\n      if (valueAfterMove.getStyleMap().size != 1) throw 'unnecessary stylePair in valueAfterMove';\n      if (axisClass == 'AxisX') {\n        if (valueAfterMove.getStyleMap().has('width')) {\n          let w = valueAfterMove.getStyleMap().get('width');\n          if (isNaN(parseInt(w, 10)) || parseInt(w, 10) !== w) throw 'horizontal resizing not updating stylePair w/ numerical value';\n          let valueBeforeMove = changeHistoryAfterMove[changeHistoryIndexBeforeMove].getIndividualEntry(entryKey);\n          if (valueBeforeMove.getStyleMap().get('width') != w - delta) throw 'width not adjusted by delta in changeHistory';\n        } else if (valueAfterMove.getStyleMap().has('marginLeft')) {\n          let ml = valueAfterMove.getStyleMap().get('marginLeft');\n          if (isNaN(parseInt(ml, 10)) || parseInt(ml, 10) !== ml) throw 'horizontal resizing not updating stylePair w/ numerical value';\n          let valueBeforeMove = changeHistoryAfterMove[changeHistoryIndexBeforeMove].getIndividualEntry(entryKey);\n          if (valueBeforeMove.getStyleMap().get('marginLeft') != ml - delta) throw 'ml not adjusted by delta in changeHistory';\n        } else throw 'horizontal resizing has stylePair property different from height/marginLeft';\n      } else if (axisClass = 'AxisY') {\n        if (valueAfterMove.getStyleMap().has('height')) {\n          let h = valueAfterMove.getStyleMap().get('height');\n          if (isNaN(parseInt(h, 10)) || parseInt(h, 10) !== h) throw 'vertical resizing not updating stylePair w/ numerical value';\n          let valueBeforeMove = changeHistoryAfterMove[changeHistoryIndexBeforeMove].getIndividualEntry(entryKey);\n          if (valueBeforeMove.getStyleMap().get('height') != h - delta) throw 'height not adjusted by delta in changeHistory';\n        } else throw 'vertical resizing has stylePair property different from height';\n      }\n    }\n    return true;\n  } catch (error) {\n    throw 'expectedChangeHistoryChanges(): ' + error;\n  }\n}\nexport { resizersTests, checkReactionOfResizing };","map":{"version":3,"names":["getInLine","nextTurn","getResizableColData","getResizableRowData","store","logError","logSuccess","resizersTests","turn","axisCellsX","document","querySelectorAll","axisCellsY","resizeSelections","length","checkReactionOfResizing","i","e","console","log","checkHorizontalResizersInitialization","elems","logMsg","forEach","elem","idx","resizer","querySelector","parseInt","style","height","error","checkVerticalResizersInitialization","width","testCaseIndex","resizeDetails","isFirstCall","totalTestCases","timer","axisCells","deltaIncrement","axisClass","getAxisClass","delta","index","myTurnNumber","mouseState","dimensionsBeforeMove","dimensionsAfterMove","changeHistoryBeforeMove","changeHistoryIndexBeforeMove","changeHistoryAfterMove","changeHistoryIndexAfterMove","setInterval","current","getResizer","clearInterval","dispatchEvent","MouseEvent","bubbles","cancelable","clientX","captureResizerData","historyState","getState","history","changeHistory","changeHistoryIndex","params","expectedTableChanges","expectedChangeHistoryChanges","errMsg","arr","Element","axisName","classList","filter","name","test","axisCell","reg","RegExp","possibleAxisClass","tableDimensions","colNum","getResizerIndex","cellWidth","rowNum","cellHeight","slice","entryKey","data","getIndividualEntries","hasIndividualEntry","dataAfter","getIndividualEntry","beforeStyleMap","getStyleMap","afterStyleMap","size","get","row","cellRow","cellCol","val","value","valueAfterMove","valueAfterMoveStyleMap","property","entries","getRow","getCellRow","getCellCol","getVal","has","w","isNaN","valueBeforeMove","ml","h"],"sources":["C:/Users/rband/Desktop/SpreadsheetPanel/client/src/components/TablePanel/handlers/resizingHandler/test.js"],"sourcesContent":["import { getInLine, nextTurn } from '../../../../tests/sequenceHelpers.js'\r\nimport { getResizableColData, getResizableRowData } from './resizingHandler.js'\r\nimport { store } from './../../../../store/store.js'\r\nimport { logError, logSuccess } from '../../../../tests/helper.js';\r\n\r\nfunction resizersTests(turn) {\r\n    let axisCellsX = document.querySelectorAll('.AxisX');\r\n    let axisCellsY = document.querySelectorAll('.AxisY');\r\n    let resizeSelections = [[axisCellsX, -5], [axisCellsY, -1], [[axisCellsX[0]], 15], [axisCellsY, 12], [[axisCellsX[0]], 20], [[axisCellsY[0]], 12]]\r\n    try {\r\n        if (resizeSelections.length > 0) checkReactionOfResizing(1, resizeSelections[0], turn, true, resizeSelections.length);\r\n        for (let i = 1; i < resizeSelections.length; ++i) checkReactionOfResizing(i + 1, resizeSelections[i], turn, false, resizeSelections.length);\r\n    } catch (e) {\r\n        console.log('resizingErr: checkReactionOfResizing param error: ' + e);\r\n        logError(null, e);\r\n    }\r\n}\r\n\r\nfunction checkHorizontalResizersInitialization() {\r\n    try {\r\n        let elems = document.querySelectorAll('.AxisX');\r\n        let logMsg = '';\r\n        elems.forEach((elem, idx) => {\r\n            let resizer = elem.querySelector('.resizer-horizontal')\r\n            if (resizer == null) {\r\n                logMsg = logMsg + 'col' + (idx + 1) + ': horizontal resizer not found\\n';\r\n            } else if (22 != (parseInt(resizer.style.height, 10))) {\r\n                logMsg = logMsg + 'col' + (idx + 1) + ': horizontal resizer does not match height of Y-axis cell \\'' + resizer.style.height + '\\' : should be \\'22px\\' \\n';\r\n            }\r\n        })\r\n        if (logMsg.length != 0) console.log(logMsg);\r\n        else console.log('horizontalResizers appended correctly');\r\n    } catch (error) {\r\n        console.log('checkHorizontalResizersInitialization(): ' + error);\r\n    }\r\n}\r\n\r\nfunction checkVerticalResizersInitialization() {\r\n    try {\r\n        let elems = document.querySelectorAll('.AxisY');\r\n        let logMsg = '';\r\n        elems.forEach((elem, idx) => {\r\n            let resizer = elem.querySelector('.resizer-vertical')\r\n            if (resizer == null) {\r\n                logMsg = logMsg + 'row' + idx + ': vertical resizer not found\\n';\r\n            } else if (50 != (parseInt(resizer.style.width, 10))) {\r\n                logMsg = logMsg + 'row' + idx + ': vertical resizer does not match width of X-axis cell \\'' + resizer.style.width + '\\' : should be \\'50px\\'\\n';\r\n            }\r\n        })\r\n        if (logMsg.length != 0) console.log(logMsg);\r\n        else console.log('verticalResizers appended correctly');\r\n    } catch (error) {\r\n        console.log('checkVerticalResizersInitialization(): ' + error);\r\n    }\r\n}\r\n\r\nfunction checkReactionOfResizing(testCaseIndex, resizeDetails, turn, isFirstCall, totalTestCases) {\r\n    let timer;\r\n    let [axisCells, deltaIncrement] = resizeDetails;\r\n    try {\r\n        let axisClass = getAxisClass(axisCells);\r\n        let resizer;\r\n        let delta = 0;\r\n        let index = -1;\r\n        let myTurnNumber = getInLine(turn);\r\n        let mouseState = -1;\r\n        let dimensionsBeforeMove;\r\n        let dimensionsAfterMove;\r\n        let changeHistoryBeforeMove;\r\n        let changeHistoryIndexBeforeMove;\r\n        let changeHistoryAfterMove;\r\n        let changeHistoryIndexAfterMove;\r\n        timer = setInterval(() => {\r\n            switch (mouseState) {\r\n                case -1: // FIFO waiting queue\r\n                    if (turn.current == myTurnNumber) {\r\n                        if (isFirstCall) {\r\n                            console.log('\\n--------RESIZING TEST-----------------------');\r\n                            checkHorizontalResizersInitialization();\r\n                            checkVerticalResizersInitialization();\r\n                        }\r\n                        mouseState = 0;\r\n                    }\r\n                    break;\r\n                case 0:\r\n                    if (++index < axisCells.length) {\r\n                        resizer = getResizer(axisCells[index], axisClass)\r\n                        mouseState++;\r\n                    } else {\r\n                        console.log('resizing affects store and DOM correctly');\r\n                        if (testCaseIndex == totalTestCases) logSuccess('resizingTest()', totalTestCases);\r\n                        nextTurn(turn); // increment turn.current\r\n                        clearInterval(timer);\r\n                    }\r\n                    break;\r\n                case 1:\r\n                    resizer.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true, clientX: 0 }));\r\n                    try {\r\n                        dimensionsBeforeMove = captureResizerData(axisClass, axisCells[index]);\r\n                        let historyState = store.getState().history;\r\n                        [changeHistoryBeforeMove, changeHistoryIndexBeforeMove] = [historyState.changeHistory, historyState.changeHistoryIndex];\r\n                    } catch (error) {\r\n                        console.log('resizingErr: ' + error);\r\n                        clearInterval(timer);\r\n                    }\r\n                    mouseState++;\r\n                    break;\r\n                case 2:\r\n                case 3:\r\n                case 4:\r\n                    let params = { bubbles: true, cancelable: true };\r\n                    params[axisClass == 'AxisX' ? 'clientX' : 'clientY'] = delta += deltaIncrement;\r\n                    resizer.dispatchEvent(new MouseEvent('mousemove', params));\r\n                    mouseState++;\r\n                    break;\r\n                case 5:\r\n                    resizer.dispatchEvent(new MouseEvent('mouseup', { bubbles: true, cancelable: true }));\r\n                    try {\r\n                        dimensionsAfterMove = captureResizerData(axisClass, axisCells[index]);\r\n                        let historyState = store.getState().history;\r\n                        [changeHistoryAfterMove, changeHistoryIndexAfterMove] = [historyState.changeHistory, historyState.changeHistoryIndex];\r\n                        if (!expectedTableChanges(axisClass, dimensionsBeforeMove, dimensionsAfterMove, delta)) throw 'mousemove: resizer not affecting table correctly';\r\n                        if (!expectedChangeHistoryChanges(axisClass, delta, changeHistoryBeforeMove, changeHistoryIndexBeforeMove, changeHistoryAfterMove, changeHistoryIndexAfterMove)) throw 'mousemove: resizer not affecting changeHistory properly';\r\n                    } catch (error) {\r\n                        console.log('resizingErr: ' + error);\r\n                        clearInterval(timer);\r\n                    }\r\n                    delta = 0;\r\n                    mouseState = 0;\r\n                    break;\r\n                default: break;\r\n            }\r\n        }, 5);\r\n    } catch (e) {\r\n        let errMsg = 'Err: checkReactionOfResizing(): { testCaseIndex: ' + testCaseIndex + ' } : ' + e;\r\n        console.log(errMsg);\r\n        logError(errMsg);\r\n        clearInterval(timer);\r\n    }\r\n}\r\n\r\nfunction getAxisClass(axisCells) {\r\n    let arr = [];\r\n    if (typeof axisCells !== typeof arr) throw 'getAxisClass(): axisCells is not an array';\r\n    if (axisCells.length == 0) throw 'getAxisClass(): axisCells is empty';\r\n    if (axisCells instanceof Element) throw 'getAxisClass(): axisCells should be an array of DOM elements'\r\n    if (!(axisCells[0] instanceof Element)) throw 'getAxisClass(): axisCells should be an array of DOM elements';\r\n    let axisName = [...axisCells[0].classList].filter(name => /^Axis.$/.test(name));\r\n    if (axisName.length == 0) throw 'getAxisClass(): axisClass not found in axisCells[0]';\r\n    if (axisName[0] != 'AxisX' && axisName[0] != 'AxisY') throw 'getAxisClass(): found axis class not equal to \"AxisX\" or \"AxisY\"'\r\n    return axisName[0];\r\n}\r\n\r\nfunction getResizer(axisCell, axisClass) {\r\n    if (!(axisCell instanceof Element)) throw 'getResizer(): axisCell should be a valid DOM element';\r\n    let reg = new RegExp(axisClass);\r\n    let possibleAxisClass = [...axisCell.classList].filter(name => reg.test(name));\r\n    if (possibleAxisClass.length == 0) throw 'getResizer(): axisCell\\'s axis class must match axis parameter';\r\n    let resizer = axisCell.querySelector(axisClass == 'AxisX' ? '.resizer-horizontal' : '.resizer-vertical');\r\n    if (!resizer instanceof Element) throw 'getResizer(): resizer not found in axisCell';\r\n    return resizer;\r\n}\r\n\r\nfunction captureResizerData(axisClass, axisCell) {\r\n    let tableDimensions = store.getState().tableDimensions;\r\n    if (axisClass == 'AxisX') {\r\n        let colNum = getResizerIndex(axisClass, axisCell);\r\n        let cellWidth = parseInt(axisCell.style.width, 10);\r\n        return getResizableColData(colNum, cellWidth, tableDimensions.width)\r\n    } else {\r\n        let rowNum = getResizerIndex(axisClass, axisCell);\r\n        let cellHeight = parseInt(axisCell.style.height, 10);\r\n        return getResizableRowData(rowNum, cellHeight, tableDimensions.height);\r\n    }\r\n}\r\n\r\nfunction getResizerIndex(axisClass, axisCell) {\r\n    if (axisClass == 'AxisX') return parseInt([...axisCell.classList].filter(name => /^col\\d+$/.test(name))[0].slice(-1), 10);\r\n    else return parseInt([...axisCell.classList].filter(name => /^row\\d+$/.test(name))[0].slice(-1), 10);\r\n}\r\n\r\n// check that when delta is applied to all width/marginLeft values in dimensionsBeforeMove,\r\n// that it is reflected in dimensionsAfterMove\r\nfunction expectedTableChanges(axisClass, dimensionsBeforeMove, dimensionsAfterMove, delta) {\r\n    try {\r\n        if (axisClass == 'AxisX') {\r\n            for (const [entryKey, data] of dimensionsBeforeMove.getIndividualEntries()) {\r\n                if (!dimensionsAfterMove.hasIndividualEntry(entryKey)) throw entryKey + ' in dimensionsBeforeMove, but not found in dimensionsAfterMove';\r\n                let dataAfter = dimensionsAfterMove.getIndividualEntry(entryKey);\r\n                let beforeStyleMap = data.getStyleMap();\r\n                let afterStyleMap = dataAfter.getStyleMap();\r\n                if (beforeStyleMap.size != 1 || afterStyleMap.size != 1) throw entryKey + ' should not have multiple styleMap entries'\r\n                if (entryKey == 'table') {\r\n                    if (beforeStyleMap.get('width') == null || afterStyleMap.get('width') == null) throw entryKey + ' is missing property \"width\"';\r\n                    if (beforeStyleMap.get('width') + delta != afterStyleMap.get('width')) throw entryKey + ' width not updated properly';\r\n                } else if (!/.col\\d+/.test(entryKey)) {\r\n                    if (beforeStyleMap.get('width') == null || afterStyleMap.get('width') == null) throw entryKey + ' is missing property \"width\"';\r\n                    if (beforeStyleMap.get('width') + delta != afterStyleMap.get('width')) throw entryKey + ' width not updated properly';\r\n                    if (data.row != dataAfter.row) throw entryKey + ' row does not match';\r\n                } else {\r\n                    if (data.cellRow != dataAfter.cellRow) throw entryKey + ' row does not match';\r\n                    if (data.cellCol != dataAfter.cellCol) throw entryKey + ' col does not match';\r\n                    if (data.val != dataAfter.val) throw entryKey + ' val does not match';\r\n                    if (beforeStyleMap.get('width') == null) {\r\n                        if (beforeStyleMap.get('marginLeft') == null || afterStyleMap.get('marginLeft') == null) throw entryKey + ' is missing property \"marginLeft\"';\r\n                        if (beforeStyleMap.get('marginLeft') + delta != afterStyleMap.get('marginLeft')) throw entryKey + ' marginLeft not updated properly';\r\n                    } else {\r\n                        if (afterStyleMap.get('width') == null) throw entryKey + ' is missing property \"width\"';\r\n                        if (beforeStyleMap.get('width') + delta != afterStyleMap.get('width')) throw entryKey + ' width not updated properly';\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (const [entryKey, data] of dimensionsBeforeMove.getIndividualEntries()) {\r\n                if (!dimensionsAfterMove.hasIndividualEntry(entryKey)) throw entryKey + ' in dimensionsBeforeMove, but not found in dimensionsAfterMove';\r\n                let dataAfter = dimensionsAfterMove.getIndividualEntry(entryKey);\r\n                let beforeStyleMap = data.getStyleMap();\r\n                let afterStyleMap = dataAfter.getStyleMap();\r\n                if (beforeStyleMap.size != 1 || afterStyleMap.size != 1) throw entryKey + ' should not have multiple styleMap entries'\r\n                if (beforeStyleMap.get('height') == null || afterStyleMap.get('height') == null) throw entryKey + ' is missing property \"height\"';\r\n                if (beforeStyleMap.get('height') + delta != afterStyleMap.get('height')) throw entryKey + ' height not updated properly';\r\n                if (!/.col\\d+/.test(entryKey)) {\r\n                    if (data.row != dataAfter.row) throw entryKey + ' row does not match';\r\n                } else {\r\n                    if (data.cellRow != dataAfter.cellRow) throw entryKey + ' row does not match';\r\n                    if (data.cellCol != dataAfter.cellCol) throw entryKey + ' col does not match';\r\n                    if (data.val != dataAfter.val) throw entryKey + ' val does not match';\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    } catch (error) {\r\n        throw 'expectedTableChanges(): ' + error;\r\n    }\r\n}\r\n\r\nfunction expectedChangeHistoryChanges(axisClass, delta, changeHistoryBeforeMove, changeHistoryIndexBeforeMove, changeHistoryAfterMove, changeHistoryIndexAfterMove) {\r\n    try {\r\n        if (changeHistoryIndexBeforeMove != changeHistoryIndexAfterMove - 1) throw 'changeHistoryIndex not updated properly';\r\n        // preservation\r\n        for (const [entryKey, value] of changeHistoryBeforeMove[changeHistoryIndexBeforeMove].getIndividualEntries()) {\r\n            if (!changeHistoryAfterMove[changeHistoryIndexBeforeMove].hasIndividualEntry(entryKey)) throw 'entry not preserved';\r\n            let valueAfterMove = changeHistoryAfterMove[changeHistoryIndexBeforeMove].getIndividualEntry(entryKey);\r\n            if (value.getStyleMap().size != valueAfterMove.getStyleMap().size) throw \"valueAfterMove does not preserve  styleMap pairs of value\";\r\n            let valueAfterMoveStyleMap = valueAfterMove.getStyleMap();\r\n            for (const [property, val] of value.getStyleMap().entries()) {\r\n                if (valueAfterMoveStyleMap.get(property) !== val) throw 'valueAfterMove does not preserve styleMap pairs of value';\r\n            }\r\n            if (!/.col\\d+/.test(entryKey) && entryKey !== 'table' && value.getRow() != valueAfterMove.getRow()) throw 'valueAfterMove does not preserve row of value';\r\n            else if (/.col\\d+/.test(entryKey) && (value.getCellRow() != valueAfterMove.getCellRow()\r\n                || value.getCellCol() != valueAfterMove.getCellCol()\r\n                || value.getVal() != valueAfterMove.getVal())) throw 'valueAfterMove does not preserve cellRow/cellCol/val of value';\r\n        }\r\n        // check resizing is reflected in changeHistoryAfterMove\r\n        for (const [entryKey, valueAfterMove] of changeHistoryAfterMove[changeHistoryIndexAfterMove].getIndividualEntries()) {\r\n            if (valueAfterMove.getStyleMap().size != 1) throw 'unnecessary stylePair in valueAfterMove';\r\n            if (axisClass == 'AxisX') {\r\n                if (valueAfterMove.getStyleMap().has('width')) {\r\n                    let w = valueAfterMove.getStyleMap().get('width');\r\n                    if (isNaN(parseInt(w, 10)) || parseInt(w, 10) !== w) throw 'horizontal resizing not updating stylePair w/ numerical value';\r\n                    let valueBeforeMove = changeHistoryAfterMove[changeHistoryIndexBeforeMove].getIndividualEntry(entryKey);\r\n                    if (valueBeforeMove.getStyleMap().get('width') != w - delta) throw 'width not adjusted by delta in changeHistory';\r\n                } else if (valueAfterMove.getStyleMap().has('marginLeft')) {\r\n                    let ml = valueAfterMove.getStyleMap().get('marginLeft');\r\n                    if (isNaN(parseInt(ml, 10)) || parseInt(ml, 10) !== ml) throw 'horizontal resizing not updating stylePair w/ numerical value';\r\n                    let valueBeforeMove = changeHistoryAfterMove[changeHistoryIndexBeforeMove].getIndividualEntry(entryKey);\r\n                    if (valueBeforeMove.getStyleMap().get('marginLeft') != ml - delta) throw 'ml not adjusted by delta in changeHistory';\r\n                } else throw 'horizontal resizing has stylePair property different from height/marginLeft';\r\n            } else if (axisClass = 'AxisY') {\r\n                if (valueAfterMove.getStyleMap().has('height')) {\r\n                    let h = valueAfterMove.getStyleMap().get('height');\r\n                    if (isNaN(parseInt(h, 10)) || parseInt(h, 10) !== h) throw 'vertical resizing not updating stylePair w/ numerical value';\r\n                    let valueBeforeMove = changeHistoryAfterMove[changeHistoryIndexBeforeMove].getIndividualEntry(entryKey);\r\n                    if (valueBeforeMove.getStyleMap().get('height') != h - delta) throw 'height not adjusted by delta in changeHistory';\r\n                } else throw 'vertical resizing has stylePair property different from height';\r\n            }\r\n        }\r\n        return true;\r\n    } catch (error) {\r\n        throw 'expectedChangeHistoryChanges(): ' + error;\r\n    }\r\n}\r\n\r\nexport { resizersTests, checkReactionOfResizing };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}