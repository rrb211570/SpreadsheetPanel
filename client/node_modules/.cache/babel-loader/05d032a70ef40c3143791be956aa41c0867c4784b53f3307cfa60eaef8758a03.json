{"ast":null,"code":"import { store } from '../../../../store/store.js';\nimport { logError, logSuccess } from '../../../../tests/helper.js';\nimport { getInLine, nextTurn } from '../../../../tests/sequenceHelpers.js';\nimport { DOWN, CONTROL, META, SHIFT, Z, Y, UNDO_DISPATCH, UNDO_FINISH, REDO_DISPATCH, REDO_FINISH, FLUFF_FULL } from './keyMacros.js';\nconst UNDO = 'Undo';\nconst REDO = 'Redo';\nconst NO_CHANGE = 'No Change';\nconst WAIT_IN_QUEUE = -1;\nconst ARRANGE_AND_ACTION = 0;\nconst ASSERT = 1;\nfunction keyInputTest(atomicTurn) {\n  let events = [UNDO_DISPATCH, UNDO_FINISH, UNDO_DISPATCH, UNDO_FINISH, REDO_DISPATCH, REDO_FINISH, REDO_DISPATCH, REDO_FINISH, REDO_DISPATCH, REDO_FINISH, FLUFF_FULL];\n  let totalTestCases = validateSequence(events);\n  if (totalTestCases == -1) return;\n  let testCaseIndex = 1;\n  try {\n    let keyState = new Set();\n    for (let i = 0; i < events.length; ++i) {\n      for (let j = 0; j < events[i].length; ++j) {\n        if (i == 0 && j == 0) checkReactionOfKeyInput(testCaseIndex, events[i][j], keyState, atomicTurn, true, totalTestCases);else checkReactionOfKeyInput(++testCaseIndex, events[i][j], keyState, atomicTurn, false, totalTestCases);\n      }\n    }\n  } catch (e) {\n    console.log('Error: checkReactionOfKeyInput param error: ' + e);\n    logError(null, e);\n  }\n}\nfunction checkReactionOfKeyInput(testCaseIndex, keyEvent, keyState, atomicTurn, isFirstCall, totalTestCases) {\n  let sheet = document.querySelector('#spreadsheet');\n  let predictedKeyOutcome = null;\n  let predictedChange = null;\n  let recordedTimeTravelCounter;\n  let myTurnNumber = getInLine(atomicTurn);\n  let stage = WAIT_IN_QUEUE;\n  let timer = setInterval(() => {\n    try {\n      let storeState = store.getState();\n      let currentTimeTravelCounter = storeState.keyboardEvents.timeTravelCounter;\n      let outcome = storeState.keyboardEvents.outcome;\n      switch (stage) {\n        case WAIT_IN_QUEUE:\n          if (atomicTurn.current == myTurnNumber) {\n            if (isFirstCall) console.log('\\n--------KEY INPUT TEST--------------------');\n            stage = ARRANGE_AND_ACTION;\n          }\n          break;\n        case ARRANGE_AND_ACTION:\n          recordedTimeTravelCounter = currentTimeTravelCounter;\n          predictedKeyOutcome = updateKeyState(keyState, keyEvent);\n          if (predictedKeyOutcome != NO_CHANGE) {\n            predictedChange = capturePredictedChange(predictedKeyOutcome, timer);\n          } else predictedChange = NO_CHANGE;\n          sheet.dispatchEvent(new KeyboardEvent(keyEvent.status == DOWN ? 'keydown' : 'keyup', {\n            key: keyEvent.id,\n            bubbles: true\n          }));\n          stage = ASSERT;\n          break;\n        case ASSERT:\n          if (predictionMatchesActualEvent(predictedKeyOutcome, outcome, recordedTimeTravelCounter, currentTimeTravelCounter, keyEvent)) {\n            console.log('-------------- Event: ' + predictedKeyOutcome);\n            compareStoreAndDOM(predictedKeyOutcome, predictedChange);\n          }\n          if (testCaseIndex == totalTestCases) logSuccess('keyInputTest()', totalTestCases);\n          nextTurn(atomicTurn);\n          clearInterval(timer);\n          break;\n        default:\n          break;\n      }\n    } catch (e) {\n      let errMsg = 'Err: checkReactionOfKeyInput(): { testCaseIndex: ' + testCaseIndex + ' } : ' + e;\n      console.log(errMsg);\n      logError(errMsg);\n      nextTurn(atomicTurn);\n      clearInterval(timer);\n    }\n  }, 100);\n}\n\n// Check that no impossible events happen, like CTRL_UP w/o a corresponding prior CTRL_DOWN\n// Also ensure the sequence is finished, that all 'DOWN' events are followed by corresponding 'UP' events\nfunction validateSequence(events) {\n  try {\n    let seen = new Set();\n    let totalEvents = 0;\n    for (let i = 0; i < events.length; ++i) {\n      for (let j = 0; j < events[i].length; ++j) {\n        let key = events[i][j];\n        if (key.status == DOWN) {\n          if (seen.has(key.id)) {\n            throw 'keyInputTest(): encountered duplicate DOWN event w/o necessary UP event in-between\\nkey: ' + key.id + ' ' + key.status + ' i: ' + i + ' j: ' + j;\n          } else seen.add(key.id);\n        } else if (seen.has(key.id)) {\n          seen.delete(key.id);\n        } else throw 'keyInputTest(): UP event encountered without prior corresponding DOWN event\\nkey: ' + key.id + ' ' + key.status + ' i: ' + i + ' j: ' + j;\n        totalEvents++;\n      }\n    }\n    if (seen.size > 0) throw 'keyInputTest(): unfinished sequence (one or more DOWN events are missing concluding UP event)';\n    return totalEvents;\n  } catch (e) {\n    console.log('Error: ' + e);\n    return -1;\n  }\n}\nfunction updateKeyState(keyState, key) {\n  if (key.status == DOWN) {\n    keyState.add(key.id);\n    if (key.id == Z && (keyState.has(CONTROL) || keyState.has(META)) && !keyState.has(SHIFT)) return UNDO;else if (key.id == Y && (keyState.has(CONTROL) || keyState.has(META)) && !keyState.has(SHIFT)) return REDO;\n  } else keyState.delete(key.id);\n  return NO_CHANGE;\n}\nfunction capturePredictedChange(predictedKeyOutcome) {\n  let storeState = store.getState();\n  let changeHistoryIndex = storeState.history.changeHistoryIndex;\n  let changeHistory = storeState.history.changeHistory;\n  let delta;\n  if (predictedKeyOutcome == UNDO) {\n    delta = -1;\n  } else if (predictedKeyOutcome == REDO) {\n    delta = 1;\n  } else throw 'capturePredictedChange(): currently unsupported outcome: ' + predictedKeyOutcome;\n  let newIndex = changeHistoryIndex + delta;\n  if (newIndex < 0 || newIndex >= changeHistory.length) return NO_CHANGE;else return {\n    predictedIndex: changeHistoryIndex + delta,\n    predictedHistoryState: changeHistory[changeHistoryIndex + delta]\n  };\n}\nfunction predictionMatchesActualEvent(predictedKeyOutcome, currentKeyOutcome, previousTimeTravelCounter, currentTimeTravelCounter, key) {\n  if (currentKeyOutcome != predictedKeyOutcome) throw 'Error: keyInputTest(): key event outcome does not match prediction:\\nkey: ' + key.id + ' ' + key.status + '\\nPredicted: ' + predictedKeyOutcome + '\\nActual: ' + currentKeyOutcome;\n  if (predictedKeyOutcome != null && previousTimeTravelCounter + 1 == currentTimeTravelCounter) return true;else return false;\n}\nfunction compareStoreAndDOM(predictedKeyOutcome, predictedChange) {\n  if (predictedChange == NO_CHANGE) {\n    console.log('NO CHANGE');\n    return;\n  }\n  let changeHistoryIndex = store.getState().history.changeHistoryIndex;\n  if (changeHistoryIndex != predictedChange.predictedIndex) throw 'changeHistoryIndex not updated correctly';\n  if (predictedKeyOutcome == UNDO) {\n    compareWithDOM(predictedChange.predictedHistoryState);\n  } else if (predictedKeyOutcome == REDO) {\n    compareWithDOM(predictedChange.predictedHistoryState);\n  } else console.log('compareStoreAndDOM(): unrecognized predictedKeyOutcome: ' + predictedKeyOutcome);\n}\nfunction compareWithDOM(predictedHistoryState) {\n  for (const [entryKey, data] of predictedHistoryState.getIndividualEntries()) {\n    if (entryKey == 'spreadsheet') compareSheet(data.getStyleMap());else if (!/\\.col\\d+/.test(entryKey)) {\n      let entry = document.getElementById(entryKey.match(/\\.row\\d+/));\n      compareEntry(entry, data.getStyleMap());\n    } else {\n      let entry = document.querySelector(entryKey.match(/\\.row\\d+\\.col\\d+$/));\n      compareEntry(entry, data.getStyleMap(), data.getVal());\n    }\n  }\n  for (const [group, styleMap] of predictedHistoryState.getGroupEntries()) {\n    compareGroup(group, styleMap);\n  }\n}\nfunction compareSheet(styleMap) {\n  let h = null;\n  let w = null;\n  for (const [property, value] of styleMap.entries()) {\n    if (property == 'height') h = value;else if (property == 'width') w = value;\n  }\n  document.getElementById('spreadsheet').querySelectorAll('.resizer-horizontal').forEach(resizer => {\n    if (h != null && resizer.style.height != h + 'px') throw 'compareSheet() failed on resizer height';\n  });\n  document.getElementById('spreadsheet').querySelectorAll('.resizer-vertical').forEach(resizer => {\n    if (w != null && resizer.style.width != w + 'px') throw 'compareSheet() failed on resizer width';\n  });\n  let dimensions = store.getState().sheetDimensions;\n  if (h != null && dimensions.tableHeight != h || w != null && dimensions.tableWidth != w) throw 'compareSheet() failed on sheet dimensions';\n}\nfunction compareEntry(entry, styleMap, val) {\n  if (val != null && entry.querySelector('input').value != val) throw 'compareEntry() failed on value';\n  for (const [property, value] of styleMap.entries()) {\n    switch (property) {\n      case 'height':\n        if (entry.style.height = !value + 'px') throw 'compareEntry() failed on height';\n        if ([...entry.classList].filter(name => /^col0$/.test(name)).length != 0 && entry.style.lineHeight != value + 'px') {\n          throw 'compareEntry() failed on lineHeight of a specific Y axis cell';\n        }\n        if ([...entry.classList].filter(name => /^row0$/.test(name)).length == 0 && [...entry.classList].filter(name => /^col0$/.test(name)).length == 0 && [...entry.classList].filter(name => /^col\\d+$/.test(name)).length != 0 && entry.querySelector('input').style.height != value - 4 + 'px' && entry.querySelector('#cover').style.height != value + 'px') {\n          throw 'compareEntry() failed on input and cover heights';\n        }\n        break;\n      case 'width':\n        entry.style.width = value + 'px';\n        if ([...entry.classList].filter(name => /^row0$/.test(name)).length == 0 && [...entry.classList].filter(name => /^col0$/.test(name)).length == 0 && [...entry.classList].filter(name => /^col\\d+$/.test(name)).length != 0 && entry.querySelector('input').style.width != value - 4 + 'px' && entry.querySelector('#cover').style.width != value + 'px') {\n          throw 'compareEntry() failed on input and cover widths';\n        }\n        break;\n      case 'marginLeft':\n        if (entry.style.marginLeft != value + 'px') throw 'compareEntry() failed on marginLeft';\n        break;\n    }\n  }\n}\nfunction compareGroup(group, styleMap) {\n  if (/^\\.col\\d+$/.test(group)) {\n    for (const [property, value] of styleMap) {\n      if (property == 'width') {\n        let entries = document.querySelectorAll(group);\n        let dx = value - parseInt(entries[0].style.width, 10);\n        if (entries[0].style.width != value + 'px') throw 'compareGroup() failed on width';\n        for (let i = 1; i < entries.length; ++i) {\n          if (entries[i].style.width != value + 'px') throw 'compareGroup() failed on width';\n          if (entries[i].querySelector('input').style.width != value - 8 + 'px') throw 'compareGroup() failed on inputWidth';\n          if (entries[i].querySelector('.selectionLayer').style.width != value + 'px') throw 'compareGroup() failed on selectionWidth';\n          if (entries[i].querySelector('.highlightLayer').style.width != value - 4 + 'px') throw 'compareGroup() failed on highlightWidth';\n        }\n        let colNum = parseInt(group.match(/(\\d+)/)[0], 10); // check that cells do not overlap\n        let elem = null;\n        let prevMarginLeft = document.querySelector(`.col${colNum}`).style.marginLeft;\n        let prevWidth = document.querySelector(`.col${colNum}`).style.width;\n        while ((elem = document.querySelector(`.col${++colNum}`)) != null) {\n          let expectedMarginLeft = parseInt(prevMarginLeft, 10) + parseInt(prevWidth, 10) + 'px';\n          let entries = document.querySelectorAll(`.col${colNum}`);\n          for (let i = 0; i < entries.length; ++i) {\n            if (entries[i].style.marginLeft != expectedMarginLeft) throw 'compareGroup() failed on marginLeft';\n          }\n          prevMarginLeft = entries[0].style.marginLeft;\n          prevWidth = entries[0].style.width;\n        }\n      }\n    }\n  } else if (/^\\.row\\d+$/.test(group)) {\n    for (const [property, value] of styleMap) {\n      if (property == 'height') {\n        let entries = document.querySelectorAll(group);\n        entries[0].style.height = value + 'px';\n        entries[1].style.height = value + 'px';\n        entries[1].style.lineHeight = value + 'px';\n        for (let i = 2; i < entries.length; ++i) {\n          if (entries[i].style.height != value + 'px') throw 'compareGroup() failed on height';\n          if (entries[i].querySelector('input').style.height != value - 6 + 'px') throw 'compareGroup() failed on inputHeight';\n          if (entries[i].querySelector('.selectionLayer').style.height != value + 'px') throw 'compareGroup() failed on selectionHeight';\n          if (entries[i].querySelector('.highlightLayer').style.height != value - 4 + 'px') throw 'compareGroup() failed on highlightHeight';\n        }\n      }\n    }\n  }\n}\nexport { keyInputTest, checkReactionOfKeyInput, validateSequence };","map":{"version":3,"names":["store","logError","logSuccess","getInLine","nextTurn","DOWN","CONTROL","META","SHIFT","Z","Y","UNDO_DISPATCH","UNDO_FINISH","REDO_DISPATCH","REDO_FINISH","FLUFF_FULL","UNDO","REDO","NO_CHANGE","WAIT_IN_QUEUE","ARRANGE_AND_ACTION","ASSERT","keyInputTest","atomicTurn","events","totalTestCases","validateSequence","testCaseIndex","keyState","Set","i","length","j","checkReactionOfKeyInput","e","console","log","keyEvent","isFirstCall","sheet","document","querySelector","predictedKeyOutcome","predictedChange","recordedTimeTravelCounter","myTurnNumber","stage","timer","setInterval","storeState","getState","currentTimeTravelCounter","keyboardEvents","timeTravelCounter","outcome","current","updateKeyState","capturePredictedChange","dispatchEvent","KeyboardEvent","status","key","id","bubbles","predictionMatchesActualEvent","compareStoreAndDOM","clearInterval","errMsg","seen","totalEvents","has","add","delete","size","changeHistoryIndex","history","changeHistory","delta","newIndex","predictedIndex","predictedHistoryState","currentKeyOutcome","previousTimeTravelCounter","compareWithDOM","entryKey","data","getIndividualEntries","compareSheet","getStyleMap","test","entry","getElementById","match","compareEntry","getVal","group","styleMap","getGroupEntries","compareGroup","h","w","property","value","entries","querySelectorAll","forEach","resizer","style","height","width","dimensions","sheetDimensions","tableHeight","tableWidth","val","classList","filter","name","lineHeight","marginLeft","dx","parseInt","colNum","elem","prevMarginLeft","prevWidth","expectedMarginLeft"],"sources":["C:/Users/rband/Desktop/SpreadsheetPanel/client/src/components/SpreadSheetPanel/handlers/keyboardEvents/test.js"],"sourcesContent":["import { store } from '../../../../store/store.js'\r\nimport { logError, logSuccess } from '../../../../tests/helper.js';\r\nimport { getInLine, nextTurn } from '../../../../tests/sequenceHelpers.js'\r\nimport { DOWN, CONTROL, META, SHIFT, Z, Y, UNDO_DISPATCH, UNDO_FINISH, REDO_DISPATCH, REDO_FINISH, FLUFF_FULL } from './keyMacros.js'\r\nconst UNDO = 'Undo';\r\nconst REDO = 'Redo';\r\nconst NO_CHANGE = 'No Change'\r\n\r\nconst WAIT_IN_QUEUE = -1;\r\nconst ARRANGE_AND_ACTION = 0;\r\nconst ASSERT = 1;\r\n\r\nfunction keyInputTest(atomicTurn) {\r\n    let events = [UNDO_DISPATCH, UNDO_FINISH, UNDO_DISPATCH, UNDO_FINISH, REDO_DISPATCH, REDO_FINISH, REDO_DISPATCH, REDO_FINISH, REDO_DISPATCH, REDO_FINISH, FLUFF_FULL];\r\n    let totalTestCases = validateSequence(events);\r\n    if (totalTestCases == -1) return;\r\n    let testCaseIndex = 1;\r\n\r\n    try {\r\n        let keyState = new Set();\r\n        for (let i = 0; i < events.length; ++i) {\r\n            for (let j = 0; j < events[i].length; ++j) {\r\n                if (i == 0 && j == 0) checkReactionOfKeyInput(testCaseIndex, events[i][j], keyState, atomicTurn, true, totalTestCases);\r\n                else checkReactionOfKeyInput(++testCaseIndex, events[i][j], keyState, atomicTurn, false, totalTestCases);\r\n            }\r\n        }\r\n    } catch (e) {\r\n        console.log('Error: checkReactionOfKeyInput param error: ' + e);\r\n        logError(null, e);\r\n    }\r\n}\r\n\r\nfunction checkReactionOfKeyInput(testCaseIndex, keyEvent, keyState, atomicTurn, isFirstCall, totalTestCases) {\r\n    let sheet = document.querySelector('#spreadsheet');\r\n    let predictedKeyOutcome = null;\r\n    let predictedChange = null;\r\n    let recordedTimeTravelCounter;\r\n    let myTurnNumber = getInLine(atomicTurn);\r\n    let stage = WAIT_IN_QUEUE;\r\n\r\n    let timer = setInterval(() => {\r\n        try {\r\n            let storeState = store.getState();\r\n            let currentTimeTravelCounter = storeState.keyboardEvents.timeTravelCounter;\r\n            let outcome = storeState.keyboardEvents.outcome;\r\n            switch (stage) {\r\n                case WAIT_IN_QUEUE:\r\n                    if (atomicTurn.current == myTurnNumber) {\r\n                        if (isFirstCall) console.log('\\n--------KEY INPUT TEST--------------------');\r\n                        stage = ARRANGE_AND_ACTION;\r\n                    }\r\n                    break;\r\n                case ARRANGE_AND_ACTION:\r\n                    recordedTimeTravelCounter = currentTimeTravelCounter;\r\n                    predictedKeyOutcome = updateKeyState(keyState, keyEvent);\r\n                    if (predictedKeyOutcome != NO_CHANGE) {\r\n                        predictedChange = capturePredictedChange(predictedKeyOutcome, timer);\r\n                    } else predictedChange = NO_CHANGE;\r\n                    sheet.dispatchEvent(new KeyboardEvent(keyEvent.status == DOWN ? 'keydown' : 'keyup', { key: keyEvent.id, bubbles: true }));\r\n                    stage = ASSERT;\r\n                    break;\r\n                case ASSERT:\r\n                    if (predictionMatchesActualEvent(predictedKeyOutcome, outcome, recordedTimeTravelCounter, currentTimeTravelCounter, keyEvent)) {\r\n                        console.log('-------------- Event: ' + predictedKeyOutcome);\r\n                        compareStoreAndDOM(predictedKeyOutcome, predictedChange);\r\n                    }\r\n                    if (testCaseIndex == totalTestCases) logSuccess('keyInputTest()', totalTestCases);\r\n                    nextTurn(atomicTurn);\r\n                    clearInterval(timer);\r\n                    break;\r\n                default: break;\r\n            }\r\n        } catch (e) {\r\n            let errMsg = 'Err: checkReactionOfKeyInput(): { testCaseIndex: ' + testCaseIndex + ' } : ' + e;\r\n            console.log(errMsg);\r\n            logError(errMsg);\r\n            nextTurn(atomicTurn);\r\n            clearInterval(timer);\r\n        }\r\n    }, 100);\r\n}\r\n\r\n// Check that no impossible events happen, like CTRL_UP w/o a corresponding prior CTRL_DOWN\r\n// Also ensure the sequence is finished, that all 'DOWN' events are followed by corresponding 'UP' events\r\nfunction validateSequence(events) {\r\n    try {\r\n        let seen = new Set();\r\n        let totalEvents = 0;\r\n        for (let i = 0; i < events.length; ++i) {\r\n            for (let j = 0; j < events[i].length; ++j) {\r\n                let key = events[i][j];\r\n                if (key.status == DOWN) {\r\n                    if (seen.has(key.id)) {\r\n                        throw 'keyInputTest(): encountered duplicate DOWN event w/o necessary UP event in-between\\nkey: ' + key.id + ' ' + key.status + ' i: ' + i + ' j: ' + j;\r\n                    } else seen.add(key.id);\r\n                } else if (seen.has(key.id)) {\r\n                    seen.delete(key.id);\r\n                } else throw 'keyInputTest(): UP event encountered without prior corresponding DOWN event\\nkey: ' + key.id + ' ' + key.status + ' i: ' + i + ' j: ' + j;\r\n                totalEvents++;\r\n            }\r\n        }\r\n        if (seen.size > 0) throw 'keyInputTest(): unfinished sequence (one or more DOWN events are missing concluding UP event)'\r\n        return totalEvents;\r\n    } catch (e) {\r\n        console.log('Error: ' + e);\r\n        return -1;\r\n    }\r\n}\r\n\r\nfunction updateKeyState(keyState, key) {\r\n    if (key.status == DOWN) {\r\n        keyState.add(key.id);\r\n        if (key.id == Z && (keyState.has(CONTROL) || keyState.has(META)) && !keyState.has(SHIFT)) return UNDO;\r\n        else if (key.id == Y && (keyState.has(CONTROL) || keyState.has(META)) && !keyState.has(SHIFT)) return REDO;\r\n    } else keyState.delete(key.id);\r\n    return NO_CHANGE;\r\n}\r\n\r\nfunction capturePredictedChange(predictedKeyOutcome) {\r\n    let storeState = store.getState();\r\n    let changeHistoryIndex = storeState.history.changeHistoryIndex;\r\n    let changeHistory = storeState.history.changeHistory;\r\n    let delta;\r\n    if (predictedKeyOutcome == UNDO) {\r\n        delta = -1;\r\n    } else if (predictedKeyOutcome == REDO) {\r\n        delta = 1;\r\n    } else throw 'capturePredictedChange(): currently unsupported outcome: ' + predictedKeyOutcome;\r\n    let newIndex = changeHistoryIndex + delta;\r\n    if (newIndex < 0 || newIndex >= changeHistory.length) return NO_CHANGE;\r\n    else return { predictedIndex: changeHistoryIndex + delta, predictedHistoryState: changeHistory[changeHistoryIndex + delta] };\r\n}\r\n\r\nfunction predictionMatchesActualEvent(predictedKeyOutcome, currentKeyOutcome, previousTimeTravelCounter, currentTimeTravelCounter, key) {\r\n    if (currentKeyOutcome != predictedKeyOutcome) throw 'Error: keyInputTest(): key event outcome does not match prediction:\\nkey: ' + key.id + ' ' + key.status + '\\nPredicted: ' + predictedKeyOutcome + '\\nActual: ' + currentKeyOutcome;\r\n    if (predictedKeyOutcome != null && previousTimeTravelCounter + 1 == currentTimeTravelCounter) return true;\r\n    else return false;\r\n}\r\n\r\nfunction compareStoreAndDOM(predictedKeyOutcome, predictedChange) {\r\n    if (predictedChange == NO_CHANGE) {\r\n        console.log('NO CHANGE');\r\n        return;\r\n    }\r\n    let changeHistoryIndex = store.getState().history.changeHistoryIndex;\r\n    if (changeHistoryIndex != predictedChange.predictedIndex) throw ('changeHistoryIndex not updated correctly');\r\n\r\n    if (predictedKeyOutcome == UNDO) {\r\n        compareWithDOM(predictedChange.predictedHistoryState);\r\n    } else if (predictedKeyOutcome == REDO) {\r\n        compareWithDOM(predictedChange.predictedHistoryState);\r\n    } else console.log('compareStoreAndDOM(): unrecognized predictedKeyOutcome: ' + predictedKeyOutcome);\r\n}\r\n\r\nfunction compareWithDOM(predictedHistoryState) {\r\n    for (const [entryKey, data] of predictedHistoryState.getIndividualEntries()) {\r\n        if (entryKey == 'spreadsheet') compareSheet(data.getStyleMap());\r\n        else if (!/\\.col\\d+/.test(entryKey)) {\r\n            let entry = document.getElementById(entryKey.match(/\\.row\\d+/));\r\n            compareEntry(entry, data.getStyleMap());\r\n        } else {\r\n            let entry = document.querySelector(entryKey.match(/\\.row\\d+\\.col\\d+$/));\r\n            compareEntry(entry, data.getStyleMap(), data.getVal());\r\n        }\r\n    }\r\n    for (const [group, styleMap] of predictedHistoryState.getGroupEntries()) {\r\n        compareGroup(group, styleMap);\r\n    }\r\n}\r\n\r\nfunction compareSheet(styleMap) {\r\n    let h = null;\r\n    let w = null;\r\n    for (const [property, value] of styleMap.entries()) {\r\n        if (property == 'height') h = value;\r\n        else if (property == 'width') w = value;\r\n    }\r\n    document.getElementById('spreadsheet').querySelectorAll('.resizer-horizontal').forEach(resizer => {\r\n        if (h != null && resizer.style.height != h + 'px') throw 'compareSheet() failed on resizer height';\r\n    });\r\n    document.getElementById('spreadsheet').querySelectorAll('.resizer-vertical').forEach(resizer => {\r\n        if (w != null && resizer.style.width != w + 'px') throw 'compareSheet() failed on resizer width';\r\n    });\r\n    let dimensions = store.getState().sheetDimensions;\r\n    if ((h != null && dimensions.tableHeight != h) || (w != null && dimensions.tableWidth != w)) throw 'compareSheet() failed on sheet dimensions';\r\n}\r\n\r\nfunction compareEntry(entry, styleMap, val) {\r\n    if (val != null && entry.querySelector('input').value != val) throw 'compareEntry() failed on value';\r\n    for (const [property, value] of styleMap.entries()) {\r\n        switch (property) {\r\n            case 'height':\r\n                if (entry.style.height = !value + 'px') throw 'compareEntry() failed on height';\r\n                if ([...entry.classList].filter(name => /^col0$/.test(name)).length != 0 && entry.style.lineHeight != value + 'px') {\r\n                    throw 'compareEntry() failed on lineHeight of a specific Y axis cell';\r\n                }\r\n                if ([...entry.classList].filter(name => /^row0$/.test(name)).length == 0 &&\r\n                    [...entry.classList].filter(name => /^col0$/.test(name)).length == 0 &&\r\n                    [...entry.classList].filter(name => /^col\\d+$/.test(name)).length != 0 &&\r\n                    entry.querySelector('input').style.height != value - 4 + 'px' &&\r\n                    entry.querySelector('#cover').style.height != value + 'px') {\r\n                    throw 'compareEntry() failed on input and cover heights';\r\n                }\r\n                break;\r\n            case 'width':\r\n                entry.style.width = value + 'px';\r\n                if ([...entry.classList].filter(name => /^row0$/.test(name)).length == 0 &&\r\n                    [...entry.classList].filter(name => /^col0$/.test(name)).length == 0 &&\r\n                    [...entry.classList].filter(name => /^col\\d+$/.test(name)).length != 0 &&\r\n                    entry.querySelector('input').style.width != value - 4 + 'px' &&\r\n                    entry.querySelector('#cover').style.width != value + 'px') {\r\n                    throw 'compareEntry() failed on input and cover widths';\r\n                }\r\n                break;\r\n            case 'marginLeft':\r\n                if (entry.style.marginLeft != value + 'px') throw 'compareEntry() failed on marginLeft';\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\nfunction compareGroup(group, styleMap) {\r\n    if (/^\\.col\\d+$/.test(group)) {\r\n        for (const [property, value] of styleMap) {\r\n            if (property == 'width') {\r\n                let entries = document.querySelectorAll(group);\r\n                let dx = value - parseInt(entries[0].style.width, 10);\r\n                if (entries[0].style.width != value + 'px') throw 'compareGroup() failed on width';\r\n                for (let i = 1; i < entries.length; ++i) {\r\n                    if (entries[i].style.width != value + 'px') throw 'compareGroup() failed on width';\r\n                    if (entries[i].querySelector('input').style.width != value - 8 + 'px') throw 'compareGroup() failed on inputWidth';\r\n                    if (entries[i].querySelector('.selectionLayer').style.width != value + 'px') throw 'compareGroup() failed on selectionWidth';\r\n                    if (entries[i].querySelector('.highlightLayer').style.width != value - 4 + 'px') throw 'compareGroup() failed on highlightWidth';\r\n                }\r\n                let colNum = parseInt(group.match(/(\\d+)/)[0], 10); // check that cells do not overlap\r\n                let elem = null;\r\n                let prevMarginLeft = document.querySelector(`.col${colNum}`).style.marginLeft;\r\n                let prevWidth = document.querySelector(`.col${colNum}`).style.width;\r\n                while ((elem = document.querySelector(`.col${++colNum}`)) != null) {\r\n                    let expectedMarginLeft = parseInt(prevMarginLeft, 10) + parseInt(prevWidth, 10) + 'px';\r\n                    let entries = document.querySelectorAll(`.col${colNum}`);\r\n                    for (let i = 0; i < entries.length; ++i) {\r\n                        if (entries[i].style.marginLeft != expectedMarginLeft) throw 'compareGroup() failed on marginLeft';\r\n                    }\r\n                    prevMarginLeft = entries[0].style.marginLeft;\r\n                    prevWidth = entries[0].style.width;\r\n                }\r\n            }\r\n        }\r\n    } else if (/^\\.row\\d+$/.test(group)) {\r\n        for (const [property, value] of styleMap) {\r\n            if (property == 'height') {\r\n                let entries = document.querySelectorAll(group);\r\n                entries[0].style.height = value + 'px';\r\n                entries[1].style.height = value + 'px';\r\n                entries[1].style.lineHeight = value + 'px';\r\n                for (let i = 2; i < entries.length; ++i) {\r\n                    if (entries[i].style.height != value + 'px') throw 'compareGroup() failed on height';\r\n                    if (entries[i].querySelector('input').style.height != value - 6 + 'px') throw 'compareGroup() failed on inputHeight';\r\n                    if (entries[i].querySelector('.selectionLayer').style.height != value + 'px') throw 'compareGroup() failed on selectionHeight';\r\n                    if (entries[i].querySelector('.highlightLayer').style.height != value - 4 + 'px') throw 'compareGroup() failed on highlightHeight';\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport { keyInputTest, checkReactionOfKeyInput, validateSequence };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}